"""
    AutoDGS: Show Marshaller or VDGS at default airports

    Copyright (C) 2025  Holger Teutsch

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
    USA
"""

class XPObj:

    def __init__(self, base_obj_fn, new_obj_fn, b_x, b_y, b_z, w, h):
        """
            b_(x,y,z) blender coordinates of lower left corner of display
            w, h width and height of display (all in m)
        """
        self.scale = 1
        self.x0 = b_x           # xform to local coordinate system
        self.y0 = b_z
        self.z0 = -b_y + 0.003   # in front of the display

        self.new_obj_fn = new_obj_fn
        self.vt_table = []
        self.idx_table = []
        self.line_table = []

        # base object
        self.bo_preamble = []
        self.bo_vt_lines = []
        self.bo_n_vt = 0
        self.bo_idx_lines = []
        self.bo_n_idx = 0
        self.bo_body = []

        # indentation control
        self.indent = 0
        self.indent_str = ""

        bo_lines = open(base_obj_fn, "r").readlines()

        i = 0
        n = len(bo_lines)
        while i < n:
            l = bo_lines[i]
            if l.startswith("VT"):
                break
            if not l.startswith("POINT_COUNTS"):
                self.bo_preamble.append(l)
            i = i + 1

        while i < n:
            l = bo_lines[i]
            l = l.strip()
            if l == "":
                i = i + 1
                continue

            if not l.startswith("VT"):
                break

            self.bo_vt_lines.append(l)
            i = i + 1

        self.bo_n_vt = len(self.bo_vt_lines)

        while i < n:
            l = bo_lines[i]
            l = l.strip()
            if l == "":
                i = i + 1
                continue

            if not l.startswith("IDX"):
                break

            self.bo_idx_lines.append(l)
            i = i + 1
            if l.startswith("IDX10"):
                self.bo_n_idx += 10
            else:
                self.bo_n_idx += 1

        self.new_obj_fn = new_obj_fn

        self.bo_body = bo_lines[i:]
        # print(f"base_obj VT: {self.bo_n_vt}, IDX: {self.bo_n_idx}")
        # print(f"{self.bo_body}")

    def _indent_inc(self):
        self.indent += 4
        self.indent_str = ' ' * self.indent

    def _indent_dec(self):
        self.indent -= 4
        self.indent_str = ' ' * self.indent

    def _add_vt(self, x, y, s, t) -> int:
        idx = self.bo_n_vt + len(self.vt_table)
        self.vt_table.append(f"VT {x + self.x0:8.5f} {y + self.y0:8.5f} {self.z0:8.5f} 0 0 1 {s:6.5f} {t:6.5f}")
        return idx

    def set_scale(self, scale):
        """factor user units -> m"""
        self.scale = scale

    def line(self, line):
        self.line_table.append(self.indent_str + line)

    def quad(self, txq, x, y, h2w = 1.0):
        x = x * self.scale
        y = y * self.scale
        w = txq.w * txq.tex.pix2m
        h = txq.h * txq.tex.pix2m * h2w
        idx = self.bo_n_idx + len(self.idx_table)
        vt0 = self._add_vt(x, y, txq.s1, txq.t1)
        vt1 = self._add_vt(x, y + h, txq.s1, txq.t2)
        vt2 = self._add_vt(x + w, y, txq.s2, txq.t1)
        vt3 = self._add_vt(x + w, y + h, txq.s2, txq.t2)

        # tris are clockwise
        self.idx_table.extend([vt0, vt1, vt2, vt1, vt3, vt2])
        self.line(f"TRIS {idx} 6")

    def char_stack(self, char_txq, x, y, dref, first = 0, last = 999, ascii = True, h2w = 1.0):
        self._indent_inc()
        self.line(f"# char stack {dref} @{x, y}")
        self.line("\n")

        n = min(last + 1, len(char_txq) + 1)
        for i in range(first, n):
            v = i
            if ascii:
                # dref is in ascii code
                if 0 <= i and i <= 9:
                    v += 48
                elif 10 <= i and i <= 35:
                    v += -10 + 65

            tx = char_txq[i]
            self.line(f"# char {i}")
            self.line("ANIM_begin")
            self._indent_inc()
            self.line(f"ANIM_hide -2 {v - 1} {dref}")
            self.line(f"ANIM_hide {v + 1} 1000 {dref}")
            self.quad(tx, x, y, h2w = h2w)
            self._indent_dec()
            self.line("ANIM_end\n")
            i += 1

        self._indent_dec()

    def hide_if_in_range(self, dref, low, high):
        self.line(f"ANIM_hide {low:0.4f} {high:0.4f} {dref}")

    def show_if_in_range(self, dref, low, high):
        self.hide_if_in_range(dref, - 10000, low - 0.001)
        self.hide_if_in_range(dref, high + 0.001, 10000)

    def show_if_eq(self, dref, val):
        self.show_if_in_range(dref, val, val)

    def trans_x(self, dx_left, dx_right, v1, v2, dref):
        """move lateral from dx_left to dx_right while dref varies between v1 and v2"""
        dx_left = dx_left * self.scale
        dx_right = dx_right * self.scale
        self.line(f"ANIM_trans {dx_left:0.4f} 0 0 {dx_right:0.4f} 0 0 {v1} {v2} {dref}")

    def trans_y(self, dy_bottom, dy_top, v1, v2, dref):
        """move verical from dy_bottom to dy_top while dref varies between v1 and v2"""
        dy_bottom = dy_bottom * self.scale
        dy_top = dy_top * self.scale
        self.line(f"ANIM_trans 0 {dy_bottom:0.4f} 0 0 {dy_top:0.4f} 0 {v1} {v2} {dref}")

    def dump(self):
        with open(self.new_obj_fn, "w", newline = '\n') as f:
            for l in self.bo_preamble:
                f.write(l)

            nvt = self.bo_n_vt + len(self.vt_table)
            nidx = self.bo_n_idx + len(self.idx_table)
            f.write(f"POINT_COUNTS {nvt} 0 0 {nidx}\n")

            f.write("\n# base obj\n")
            for l in self.bo_vt_lines:
                f.write(l + "\n")

            f.write("\n# display\n")
            for l in self.vt_table:
                f.write(l + "\n")

            f.write("\n# base obj\n")
            for l in self.bo_idx_lines:
                f.write(l + "\n")

            f.write("\n# display\n")
            n = len(self.idx_table)
            i = 0
            while n > 10:
                f.write("IDX10")
                for j in range(i, i + 10):
                    f.write(f" {self.idx_table[j]}")
                f.write("\n")
                i += 10
                n -= 10

            for idx in self.idx_table[i:]:
                f.write(f"IDX {idx}\n")

            # place display at the end of first LOD section or the very end
            f.write("\n# base obj\n")
            n_LOD = 0
            display_added = False
            for l in self.bo_body:
                if "LOD" in l:
                    n_LOD += 1
                    if n_LOD == 2:
                        display_added = True
                        f.write("\n# display\n")
                        for ld in self.line_table:
                            f.write(ld + "\n")
                        f.write("\n# continue base obj\n")

                f.write(l)

            if not display_added:
                f.write("\n# display\n")
                for ld in self.line_table:
                    f.write(ld + "\n")
                f.write("\n# continue base obj\n")

        print(f"obj written to '{self.new_obj_fn}'")

class Texture:
    def __init__(self, xpo, w, h, pix2m):
        self.xpo = xpo
        self.w = w
        self.h = h
        self.pix2m = pix2m

class TexQuad:
    def __init__(self, tex, x, y, w, h, mirror_x = False):
        """in pixels with (0,0) = upper left corner = rectangle selection in GIMP"""
        self.tex = tex
        self.w = w
        self.h = h
        self.s1 = x / tex.w
        self.t1 = (tex.h - (y + h)) / tex.h
        self.s2 = (x + w) / tex.w
        self.t2 = (tex.h - y) / tex.h
        if mirror_x:
            s = self.s2
            self.s2 = self.s1
            self.s1 = s

        #print(f"{self.s1:0.2f} {self.t1:0.2f}")

class AnimBlock:
    """manage a "ANIM_begin / ANIM_end" block"""

    def __init__(self, xpo):
        self.xpo = xpo

    def __enter__(self):
        self.xpo.line("ANIM_begin")
        self.xpo._indent_inc()

    def __exit__(self, type, value, traceback):
        self.xpo._indent_dec()
        self.xpo.line("ANIM_end")
